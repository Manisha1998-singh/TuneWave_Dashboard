# TuneWave_Dashboard

https://cors-anywhere.herokuapp.com/ should i add every time for cors issues with every url is it naccesy or it is right?

Good question, Mannu ğŸŒŸ â€” using
https://cors-anywhere.herokuapp.com/
is fine only for learning and testing, but not recommended for real projects.

Hereâ€™s why ğŸ‘‡

âš ï¸ **Why you shouldnâ€™t rely on it permanently**

// IMPORTANT : Public proxy = not secure

Your API request and data go through someone elseâ€™s server.

That proxy could log, throttle, or block requests anytime.

Temporary access

The demo server requires you to click â€œRequest temporary accessâ€ every few hours.

Itâ€™s not stable for production or even long-term development.

Rate limits

The free Heroku demo is rate-limited and sometimes shuts down due to overload.

**âœ… # The Right Way (Safe & Permanent Fixes)**

You have 3 good options:

Option 1: Use your own backend proxy

If your React app runs on Vite, create a proxy in vite.config.js:

export default {
server: {
proxy: {
"/api": {
target: "https://itunes.apple.com",
changeOrigin: true,
rewrite: (path) => path.replace(/^\/api/, "fetch("/api/search?term=arijit+singh&entity=song&limit=150");"),
},
},
},
};

Then call:

fetch("/api/search?term=arijit+singh&entity=song&limit=150");

âœ… No need for CORS-anywhere
âœ… Secure â€” runs through your local dev server

Option 2: Use a small backend (Node/Express)

You can create a simple Express server that forwards requests:

app.get("/api/music", async (req, res) => {
const response = await fetch(`https://itunes.apple.com${req.url}`);
const data = await response.json();
res.json(data);
});

âœ… Fully under your control
âœ… Works in production too

Option 3: Use APIs that already support CORS (like Spotify API)

Spotifyâ€™s API supports CORS by default â€” so you wonâ€™t need any proxy at all.

Perfect ğŸ‘ Mannu! Letâ€™s set up a Vite proxy step-by-step â€” this is the cleanest and most secure way to solve CORS issues in your React + Vite project.

âš™ï¸ STEP 1: Open your project folder

Open your React project created with Vite â€” the one that has this structure:

my-project/
â”£ src/
â”£ public/
â”£ vite.config.js
â”£ package.json

ğŸ§© STEP 2: Open vite.config.js

It should look something like this:

import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

export default defineConfig({
plugins: [react()],
});

Now, add a proxy configuration inside the server section ğŸ‘‡

âœ… STEP 3: Add proxy setup
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

export default defineConfig({
plugins: [react()],
server: {
proxy: {
"/itunes": {
target: "https://itunes.apple.com",
changeOrigin: true,
rewrite: (path) => path.replace(/^\/itunes/, ""),
},
},
},
});

ğŸ§ STEP 4: Use it in your fetch call

Now you can safely call iTunes API without using CORS-anywhere.

Example:

const response = await fetch(
`/itunes/search?term=${artistName}&entity=song&limit=150`
);
const data = await response.json();
console.log(data);

âœ… No cors-anywhere
âœ… No need to request access
âœ… Secure and runs directly through your Vite dev server

ğŸ§  STEP 5: Restart the dev server

After saving your vite.config.js, stop your app (Ctrl + C in terminal) and restart it:

npm run dev
ğŸ§  In summary:

If you want to follow standard convention â†’ put <BrowserRouter> in main.jsx.

If you want to keep it all in one file (simple demo or small project) â†’ keeping it in App.jsx is totally fine.

ğŸ§  Which to use?

If itâ€™s a clickable text or link â€” use <Link> âœ…

If itâ€™s triggered by logic or button â€” use useNavigate()

ğŸ’¡ What is Hydration?

Hydration is the process where React takes over HTML that was already rendered by the server and â€œattachesâ€ its event listeners and state management to it on the client side.

When you use Server-Side Rendering (SSR) (like Next.js or ReactDOMServer), the server sends fully rendered HTML to the browser.

This HTML looks complete, but itâ€™s static â€” buttons wonâ€™t work, inputs wonâ€™t respond, etc.

Hydration is React reading that HTML and making it interactive by attaching all the JavaScript behavior.

ğŸ”¹ Example

Server sends HTML:

<div id="root">
  <p>Hello World</p>
  <button>Click me</button>
</div>

After hydration, React attaches the click handler and any state:

<button onClick={() => alert("Clicked!")}>Click me</button>

Now, the button is interactive.

ğŸ”¹ Why your error appears

React does strict checks during hydration.

If the HTML generated by the server does not match what React expects on the client, you get hydration errors.

Example: <p> inside <p> â€” the server may render it, but React considers it invalid HTML. So hydration fails or warns.

ğŸ”¹ Key takeaway

Hydration = making server-rendered HTML interactive with React.

To avoid errors:

HTML must be valid.

DOM structure on the server must match what React renders on the client.
â­ Super Simple Comparison
useState
Click â†’ state changes â†’ React re-renders â†’ UI changes

useRef
Click â†’ ref changes â†’ NO re-render â†’ UI same

ğŸ‰ Want me to show the SAME example with a play button?

Like:

one version using useState (UI changes)

one version using useRef (UI does not change)
âœ… 1. React.memo
What it does:

React.memo prevents a component from re-rendering unless its props change.

Why you should use it:

Your project has multiple components like:

<MusicList />

<SideBar />

<LikedSongs />

<Search />

Some of these do not need to re-render every time unless props or Redux values change.

Your project example:
export default React.memo(MusicList);

When it helps in your project:

When you click on songs â†’ only that song should re-render, not whole sidebar/dash.

When switching tabs in sidebar â†’ MusicList shouldn't render again if songs didn't change.

When songs list is large â†’ memo prevents unnecessary renders â†’ faster UI.

âœ… 2. useEffect
What it does:

Runs a function after render.
Used for:

calling APIs

adding event listeners

updating document title

syncing state

Your project example:

You use useEffect for API calls:

useEffect(() => {
dispatch(fetchSongs());
}, [dispatch]);

Why it's needed in your project:

Fetch songs only once when MusicList loads.

Update UI when URL, tab, or Redux state changes.

Avoid running API calls multiple times.

Other examples in your music player:

Play / pause audio when selected song changes.

Save liked songs to localStorage.

âœ… 3. useMemo
What it does:

Caches a calculation so it doesnâ€™t re-calculate on every render.

Why use it in your project:

Your songs list may be large (50â€“200 songs).
Filtering, sorting, or finding a song every time is expensive.

Example based on your project:
const filteredSongs = useMemo(() => {
return songs.filter((song) =>
song.title.toLowerCase().includes(searchText.toLowerCase())
);
}, [songs, searchText]);

What this does:

When typing in search bar â†’ only re-calculates filtered songs when needed.

Prevents slow rendering when large data list.

ğŸ¯ Summary (Easy to remember)
Hook / Feature What it does Why YOU use it in your project
React.memo Stops unnecessary re-renders Sidebar, MusicList, LikedSongs should NOT re-render every time
useEffect Runs code after render Fetch API, load songs, play/pause audio
useMemo Caches calculated values Search filter, sorting, expensive loops on songs list
